---
title: "lab 7 warmup"
output: html_document
date: "2024-02-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(janitor)
library(skimr)
```

```{r}
superhero_powers <- readr::read_csv("data/super_hero_powers.csv")
```

```{r}
superhero_powers <- clean_names(superhero_powers)
superhero_powers
```

## `mutate()`  
Mutate allows us to create a new column from existing columns in a data frame.
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
```

## `mutate_all()`
This last function is super helpful when cleaning data. With "wild" data, there are often mixed entries (upper and lowercase), blank spaces, odd characters, etc. These all need to be dealt with before analysis.  
```{r}
mammals %>%
  mutate_all(tolower)
```

Using the across function we can specify individual columns.
```{r}
mammals %>% 
  mutate(across(c("order", "family"), tolower))
```

## `if_else()`
We will briefly introduce `if_else()` here because it allows us to use `mutate()` but not have the entire column affected in the same way. In a sense, this can function like find and replace in a spreadsheet program. With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.
```{r}
mammals %>% 
  select(genus, species, newborn) %>% 
  arrange(newborn)
```

```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
  arrange(newborn)
```

## Data tidy
1. Some of the names used in the `superhero_info` data are problematic so you should rename them here. Before you do anything, first have a look at the names of the variables. You can use `rename()` or `clean_names()`.  
```{r}
superhero_info <- clean_names(superhero_info)
superhero_powers <- clean_names(superhero_powers)
```

## `tabyl`
The `janitor` package has many awesome functions that we will explore. Here is its version of `table` which not only produces counts but also percentages. Very handy! Let's use it to explore the proportion of good guys and bad guys in the `superhero_info` data.  
```{r}
tabyl(superhero_info$alignment)
```

```{r}
 neutral_heros <- superhero_info %>% 
filter(alignment == "neutral")
table(neutral_heros$name)
```

4. List all of the superheros that are not human.
```{r}
superhero_info %>% 
  filter(race != "human")
```

```{r}
superhero_info %>% 
  mutate(height_weight_ratio = height/weight) %>% 
  arrange(desc(height_weight_ratio))
```

To find out what type of data you are working with, use the `class()` function. This is important because sometimes we will need to change the type of data to perform certain analyses.
```{r}
class(my_numeric)
class (my_integer)
```

```{r}
my_numeric <- 42
my_integer <- 2L #adding an L automatically denotes an integer
my_character <- "universe"
my_logical <- FALSE
my_complex <- 2+4i
```

You can use the `is()` and `as()` functions to clarify or specify a type of data.
```{r}
is.integer(my_numeric) #is my_numeric an integer?
```

```{r}
my_integer <- 
  as.integer(my_numeric) #create a new object specified as an integer
```

```{r}
is.integer(my_integer) #is my_numeric an integer?
```

#remove NAs from data
na.rm=T 

```{r}
fisheries$country <- as_factor(fisheries$country)
fisheries$fao_major_fishing_area <- as_factor(fisheries$fao_major_fishing_area)  
fisheries$isscaap_group_number <- as_factor(fisheries$isscaap_group_number)
fisheries$asfis_species_number <- as_factor(fisheries$asfis_species_number) 
```
### ^ clunky way to change column class



```{r}
fisheries %>% 
  select(country,isscaap_group_number, asfis_species_number, asfis_species_name, contains("1"))
```
### ^ when using select you can use contains() or starts_with/ends_with() to narrow


```{r}
fisheries_tidy %>% 
  filter(year == "2012") %>% 
  filter(country == "Estonia") %>% 
  group_by(asfis_species_name) %>% 
  summarise(most_popular_fish_estonia = sum(catch, na.rm = TRUE)) %>% 
  arrange(desc(most_popular_fish_estonia))

```
### ^ for pulling out data specific details and complicated

`count()` is an easy way of determining how many observations you have within a column. It acts like a combination of `group_by()` and `n()`.
```{r}
penguins %>% 
  count(island, sort = T) #sort=T sorts the column in descending order
```


### basic stuff
```{r}
Sex <- c("male", "female", "male")
Length <- c(3.2, 3.7, 3.4)
Weight <- c(2.9, 4.0, 3.1)
```

Here we combine our three vectors to create a data frame with the function `data.frame()`.
```{r}
hbirds <- data.frame(Sex, Length, Weight)
hbirds
```


## Writing Data to File
We should save our hbirds data frame so we can use it again later! There are many ways to save data in R, here we write our data frame to a csv file. We use `row.names = FALSE` to avoid row numbers from printing out. 
```{r}
write.csv(hbirds, "hbirds_data.csv", row.names = FALSE)
```

Use the `str()` function to get an idea of the data structure of `hot_springs`.  
```{r}
str(hot_springs)
```

What is the class of the scientist column? Change it to factor and then show the levels of that factor.  
```{r}
class(hot_springs$scientist)
```

`head()` prints the first n rows of the data frame.
```{r}
head(fish)
```

### head gives first part of data
`tail()` prinst the last n rows of the data frame.
```{r}
tail(fish)
```

### tail gives last part of data

When columns are sequentially named, `starts_with()` makes selecting columns easier.
```{r}
select(fish, starts_with("radii"))
```

Options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
2. contains() = Select columns that contain a character string  
3. matches() = Select columns that match a regular expression  
4. one_of() = Select columns names that are from a group of names  

### in select you can use^^^

```{r}
select_if(fish, is.numeric)
```

To select all columns that are *not* a class of data, you need to add a `~`.
```{r}
select_if(fish, ~!is.numeric(.))
```
### you need to add exclimation point because it mean not so altogether ~!
### you can select based on what class of data you are looking for

Using the `!` operator allows for the exclusion of specific observations.
```{r}
filter(fish, lakeid != "AL") ### ! means not
```

```{r}
not_al <- filter(fish, lakeid != "AL")
```

### same as before 
```{r}
filter(fish, lakeid == "AL" & length > 350)
```

Notice that the `|` operator generates a different result.
```{r}
filter(fish, lakeid == "AL" | length > 350)
```

Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met.  

### ^ details on the rules of AND, OR commands